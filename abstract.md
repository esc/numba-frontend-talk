Redesigning the Numba Frontend for Rapidly Changing Python Bytecode
===================================================================

Abstract
--------

The advent of the new Python release policy has resulted in a number of
challenges for the Numba project, as the Python bytecode is the input to
Just-in-time (JIT) compile Python functions. The Python bytecode implementation
-- however -- is subject to constant changes with every new Python _minor_
release, resulting in additional complexity for Numba to support these changes.
In this talk I will present a new approach to regularize bytecode based on
`RVSDG`s (Regionalized State Value Dependency Graphs) which will simplify
adding support for new Python _minor_ versions to Numba. Additionally, the new
approach has the potential to become the new common intermediary representation
for bytecode to be consumed by third-party projects such as `JAX` and
`PyTensor`.  I will conclude the talk with an outlook of potential innovations
in compiler technologies for scientific computing use-cases.

Description
-----------

The advent of the new Python release policy has resulted in a number of
challenges for the Numba project. Numba uses the Python bytecode as an input to
Just-In-Time (JIT) compile Python functions. Unfortunately the bytecode was
never designed to be stable and was not intended to serve as a public
interface. As such the bytecode implementation is subject to constant change
with every new Python minor version, new bytecodes are regularly introduced and
the behaviour of existing byetcodes themselves may change in subtle, sometimes
non-documented ways. While this flexibility is advantageous in terms of
performance for the CPython interpreter it does create additional work for any
project attempting to consume the bytecode.

The challenge that Numba faces is that significant work is needed every year in
order to support the latest Python minor version. While this work is indeed
principled, usually some decisions need to be taken which lead to an increase
in Numba's code complexity. For example, sometimes bytecode sequences need to
be rewritten, such that they match an older minor version of Python where the
bytecode sequence was less complicated. In this talk I will introduce a new
approach, based on formal methods, to regularize (or canonicalize) Python
bytecode and thus transform any bytecode into a predictable and stable form.

The approach is inspired by recent publications in theoretical computer science
related to the construction of so-called Regionalized State Value Dependency
Graphs (RVSDGs). The Numba implementation does not use RVSDGs directly,
instead we have discovered an intermediary representation introduced in
Bahmann2015[1] that is sufficient for Numba's needs. The basic idea is to take
the bytecode as generated by CPython, which effectively describes a Control
Flow Graph (CFG) of basic blocks and transform this into a canonical form. Some
features of this form are the clear identification of branching (if-else)
regions and looping (for, while) regions as well as the insertion of synthetic
blocks such that all regions are closed ("closed" in this context means: there
is only a single entry edge/arc and single exit edge/arc from any given
region). As a result much of Numba's  bytecode resequencing (peephole
(de)optimizers) can be removed and this significantly simplifies much of the
dataflow analysis.

In this talk I will present the theoretical approach to regularizing bytecode
based on RVSDGs, supplemented by examples and snippets from the Numba
code-base.  I will further explain how this new form allows Numba to be
specialised for any given Python minor version and how it relinquishes the need
for complex code. Looking into the future, I will present potential
opportunities for tools such as JAX, PyTensor and others to consume this form.
This would establish the form as a common intermediary representation of the
bytecode for any given minor version.  This means that consumers would receive
a computationally equivalent CFG representation irrespective of the Python
minor version used.  Ideally the Python minor bytecode version would thus be
abstracted away leading to simplification for any tools attempting to consume a
Python program in its bytecode representation.  This technique will enable
opportunities to open gateways into the future and will provide us with ample
possibilities for sustained research and innovation.

Furthermore, this approach is part of a larger effort to transform the Numba
project into a modular compiler toolkit. To conclude I will outline how this
enables the creation of highly specialised compilers for a number of
scientific-computing use-cases and allows application developers and scientists
to fully leverage the various types of heterogeneous silicon, beyond
multi-core, that are currently emerging.


[1] Bahmann, H., Reissmann, N., Jahre, M., & Meyer, J. C. (2015). Perfect
reconstructability of control flow from demand dependence graphs. ACM
Transactions on Architecture and Code Optimization (TACO), 11(4), 1-25.
https://dl.acm.org/doi/pdf/10.1145/2693261
